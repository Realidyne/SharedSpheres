using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.XR.iOS;
using UnityEngine.EventSystems;

public class BallMaker : MonoBehaviour {

	public GameObject ballPrefab;
	public float createHeight;
	public float maxRayDistance = 30.0f;
	public LayerMask collisionLayer = 1 << 10;  //ARKitPlane layer
	private MaterialPropertyBlock props;

	// Use this for initialization
	void Start () {
		props = new MaterialPropertyBlock ();

	}

	List<GameObject> balls = new List<GameObject>();
	List<Vector3> ballPos = new List<Vector3>();


	public void ClearBalls() {
		for (int i = 0; i < balls.Count; i++) {
			GameObject ball = balls [i];

			GameObject.Destroy (ball);

		}

		balls.Clear ();
		ballPos.Clear ();


	}

	public void SaveBalls(string saveName) {
		PlayerPrefsX.SetVector3Array (saveName + "balls", ballPos.ToArray ());


	}

	List<Vector3> ballPosTemp = new List<Vector3>();
	public void LoadBalls(string saveName) {
		ClearBalls ();

		ballPosTemp.AddRange (PlayerPrefsX.GetVector3Array (saveName + "balls"));

		for (int i = 0; i < ballPosTemp.Count; i++) {
			CreateBall (ballPosTemp [i]);

		}
		ballPosTemp.Clear ();

	}

	void CreateBall(Vector3 atPosition)
	{
		GameObject ballGO = Instantiate (ballPrefab, atPosition, Quaternion.identity);
			
		
		float r = Random.Range(0.0f, 1.0f);
		float g = Random.Range(0.0f, 1.0f);
		float b = Random.Range(0.0f, 1.0f);

		props.SetColor("_InstanceColor", new Color(r, g, b));

		MeshRenderer renderer = ballGO.GetComponentInChildren<MeshRenderer>();
		renderer.SetPropertyBlock(props);


		balls.Add (ballGO);
		ballPos.Add (ballGO.transform.position);



	}
	private bool IsPointerOverUIObject() {
		PointerEventData eventDataCurrentPosition = new PointerEventData(EventSystem.current);
		eventDataCurrentPosition.position = new Vector2(Input.mousePosition.x, Input.mousePosition.y);
		List<RaycastResult> results = new List<RaycastResult>();
		EventSystem.current.RaycastAll(eventDataCurrentPosition, results);
		return results.Count > 0;
	}


	// Update is called once per frame
	void Update () {

		if (Input.GetKeyDown (KeyCode.F)) {
			CreateBall (new Vector3 (0, 0, 0));


		}
		#if UNITY_EDITOR   //we will only use this script on the editor side, though there is nothing that would prevent it from working on device
		if (Input.GetMouseButtonDown (0)) 
		{
			Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);
			RaycastHit hit;


		//EventSystem.current.is
			//we'll try to hit one of the plane collider gameobjects that were generated by the plugin
			//effectively similar to calling HitTest with ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent
			if (Physics.Raycast (ray, out hit, maxRayDistance, collisionLayer)) 
			{
				CreateBall (new Vector3 (hit.point.x, hit.point.y + createHeight, hit.point.z));

				//we're going to get the position from the contact point
				Debug.Log (string.Format ("x:{0:0.######} y:{1:0.######} z:{2:0.######}", hit.point.x, hit.point.y, hit.point.z));
			}
		}
		#else
		if (Input.touchCount > 0 && !IsPointerOverUIObject())
		{
			var touch = Input.GetTouch(0);
			if (touch.phase == TouchPhase.Began)
			{
				var screenPosition = Camera.main.ScreenToViewportPoint(touch.position);
				ARPoint point = new ARPoint {
					x = screenPosition.x,
					y = screenPosition.y
				};
						
				List<ARHitTestResult> hitResults = UnityARSessionNativeInterface.GetARSessionNativeInterface ().HitTest (point, 
					ARHitTestResultType.ARHitTestResultTypeExistingPlaneUsingExtent);
				if (hitResults.Count > 0) {
					foreach (var hitResult in hitResults) {
						Vector3 position = UnityARMatrixOps.GetPosition (hitResult.worldTransform);
						CreateBall (new Vector3 (position.x, position.y + createHeight, position.z));
						break;
					}
				}

			}
		}
		#endif

	}

}
